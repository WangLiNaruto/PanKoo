# 六大原则

## SRP `单一职责原则(Single Responsibility Principle)`
 
    There should never be more than one reason for a class to change
    对类来说,应该有且仅有一个原因引起类的变更，一个类只负责一项职责.

### 优点
* 类的复杂性降低，实现什么职责都有清晰明确的定义；
* 可读性提高，复杂性降低，那当然可读性提高了；
* 可维护性提高，可读性提高，那当然更容易维护了；
* 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助

### 缺点
* 职责划分困难：单一职责原则最难划分的就是职责。一个职责一个接口，但问题是“职责”没有一个量化的标准，一个类到底要负责那些职责？这些职责该怎么细化？ 细化后是否都要有一个接口或类？
* 过度细化：过分细分类的职责会人为地增加系统的复杂性。本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性

### 细节
* 对于接口，我们在设计的时候一定要做到单一，但是对于实现类就需要多方面考虑，单一职责适用于接口、类，同时也适用于方法(一个方法尽可能做一件事情)
* 单一职责原则提出了一个编写程序的标准，用`职责`或`变化原因`来衡量接口或类设计得是否优良，但是`职责`和`变化原因`都是不可度量的，因项目而异，因环境而异.


## ISP `接口隔离原则(Interface Segregation Principle)`

    Clients should not be forced to depend upon interfaces that they don't use.
    The dependency of one class to another one should depend on the smallest possible interface.
    客户端不应该依赖它不需要的接口,类间的依赖关系应该建立在最小的接口上
    
    建立单一接口，不要建立臃肿庞大的接口。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少。
    看到这里大家有可能要疑惑了，这与单一职责原则不是相同的吗？
    错，接口隔离原则与单一职责的审视角度是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，
    而接口隔离原则要求接口的方法尽量少

### ISP含义
* 接口要尽量小 
>接口隔离原则的核心定义，不出现臃肿的接口(不违反单一职责原则),根据接口隔离原则拆分接口时，首先必须满足单一职责原则
* 接口要高内聚
>高内聚就是提高接口、类、模块的处理能力，减少对外的交互,具体到接口隔离原则就是，要求在接口中尽量 少公布public方法，接口是对外的承诺，
  承诺越少对系统的开发越有利，变更的风险也就越 少，同时也有利于降低成本
* 定制服务
>定制服务就是单独为一个个体提供优良
的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用
定制服务就必然有一个要求：只提供访问者需要的方法
* 接口设计是有限度的
>接口的设计粒度越小，系统越灵活,但是，灵活的同时也带来了结构 的复杂化，开发难度增加，可维护性降低,所以接口 设计一定要注意适度

### 细节
接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装,一个接口只服务于一个子模块或业务逻辑

## LSP `里氏替换原则(Liskov Substitution Principle)`

### 继承的优缺点
#### `优点`
* 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性
* 提高代码的重用性
* 提高代码的可扩展性
* 提高产品或项目的开放性
#### `缺点`
* 继承是侵入性的
* 降低代码的灵活性
* 增强了耦合性

### 里氏替换原则定义
>If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.
>如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型

>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.
>所有引用基类的地方必须能透明地使用其子类的对象,而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类


### 含义
里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义
* 子类必须完全实现父类的方法
* 子类可以有自己的个性
* 覆盖或实现父类的方法时输入参数可以被放大
* 覆写或实现父类的方法时输出结果可以被缩小

### 细节
>在项目中，采用里氏替换原则时，尽量避免子类的“个性”，一旦子类有“个性”，
这个子类和父类之间的关系就很难调和了，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；
把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准


## DIP `依赖倒置原则(Dependence Inversion Principle)`

    到底什么是“倒置”呢？我们先说“正置”是什么意思，依赖正置就是类间的依赖是实实在在的实现类间的依赖，也就是面向实现编程，这也是正常人的思维方式，
    而编写程序需要的是对现实世界的事物进行抽象，抽象的结果就是有了抽象类和接口，然后我们根据系统设计的需要产生了抽象间的依赖，代替了人们传统思维中的事物间的依赖，
    “倒置”就是从这里产生的

    High level modules should not depend upon low level modules.Both should depend upon
    abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.
    翻译过来，包含三层含义：

* 高层模块不应该依赖低层模块,两者都应该依赖其抽象
* 抽象不应该依赖细节
* 细节应该依赖抽象
>高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。
那什么是抽象？什么又是细节呢？在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的； 细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，
也就是可以加上一个关键字new产生一个对象。依赖倒置原则在Java语言中的表现就是
* 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的
* 接口或抽象类不依赖于实现类
* 实现类依赖接口或抽象类，更加精简的定义就是“面向接口编程”——OOD（Object-Oriented Design，面向对象设计）的精髓之一

### 优点
* 代码的扩展性和可维护性增加
* 减少因需求变化引起的工作量剧增的情况
* 依赖倒置原则是6个设计原则中最难以实现的原则，它是实现开闭原则的重要途径，依赖倒置原则没有实现，就别想实现对扩展开放，对修改关闭

### 依赖的三种写法

依赖是可以传递的，A对象依赖B对象，B又依赖C，C又依赖D……生生不息，依赖不止，记住一点：只要做到抽象依赖，即使是多层的依赖传递也无所畏惧：
* 构造函数传递依赖对象
>在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入
* Setter方法传递依赖对象
>在抽象中设置Setter方法声明依赖关系，依照依赖注入的说法，这是Setter依赖注入
* 接口声明依赖对象
>在接口的方法中声明依赖对象

### 细节
  依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立， 不互相影响，实现模块间的松耦合，
  我们怎么在项目中使用这个规则呢？只要遵循以下的几个规则就可以

* 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
>依赖倒置的基本要求，接口和抽象类都是属于抽象的，有了抽象才可能依赖倒置

* 变量的表面类型尽量是接口或者是抽象类
>很多书上说变量的类型一定要是接口或者是抽象类，这个有点绝对化了，比如一个工具 类，xxxUtils一般是不需要接口或是抽象类的。
还有，如果你要使用类的clone方法，就必须使用实现类，这个是JDK提供的一个规范 

* 任何类都不应该从具体类派生

* 尽量不要覆写基类的方法
>如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是
  抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响

* 结合里氏替换原则使用
>结合里里氏替换原则，父类出现的地方子类就能出现接，得出这样一个通俗的规则`接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化`

## LOD `迪米特法则(Law of Demeter)`
    迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least KnowledgePrinciple，LKP），虽然名字不同，但描述的是同一个规则：
    一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少

## OCP `开闭原则(open closed Principle)`
    Software entities like classes,modules and functions should be open for extension but closed for modifications
    一个软件实体如类、模块和函数应该对扩展开放，对修改关闭

    开闭原则是编程中最基础、最重要的原则.开闭原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化，
    它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则,用抽象构建框架，用实现扩展细节.

    模块和函数应该对扩展开放-提供方,对修改关闭-使用方

### 优点：
* 开闭原则是最基础的一个原则
>其他原则都是开闭原则的具体形态， 也就是说前五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖。换一个角度来理解，依照Java语言的称谓，开闭原则是抽象类，其他五大原则是具体的实现类
* 开闭原则可以提高复用性
* 开闭原则可以提高可维护性
* 面向对象开发的要求

### 使用
    开闭原则是一个非常虚的原则，前面5个原则是对开闭原则的具体解释，但是开闭原则并不局限于这么多，它“虚”得没有边界
* 抽象约束
>抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。
> 因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：
>> 1、通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法
>> 2、参数类型、引用对象尽 量使用接口或者抽象类，而不是实现类
>> 3、抽象层尽量保持稳定，一旦确定即不允许修改
* 元数据（metadata）控制模块行为
>尽量使用元数据来控制程序的行为，减少重复开发。
> 什么是元数据？用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得
* 封装变化
>封装变化，也就是受保护的变化（protected variations），找出预计有变化或不稳
定的点，我们为这些变化点创建稳定的接口，准确地讲是封装可能发生的变化，一旦预测到
或“第六感”发觉有变化，就可以进行封装
> 第一，将相同的变化封装到一个接口或抽象类中
> 第二， 将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中
